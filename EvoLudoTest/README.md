# [*EvoLudo*](https://www.evoludo.org) Tests
***Testing consistency of the Evolutionary Dynamics Simulation Toolkit***

Historically, for reasons of efficiency *java* provided minimal freedom in the actual implementations of mathematical functions on different architectures. Primarily this relates to the numerical accuracy in intermediate results. For example, using an extended range for exponents for intermediate calculations could prevent numerical overflows or underflows in the final result, while sticking to *java*'s `double` precision throughout would yield in a different result.

In order to address this issue, the class `java.lang.Math` is accompanied by `java.lang.StrictMath`, which ensures that all intermediate results are also restricted to *java*'s `double` precision and hence become reproducible between platforms.

However, since *java 17* the keyword `strictfp` is deprecated and all floating-point expressions are evaluated strictly such that `strictfp` is no longer needed. By extension `Math` and `StrictMath` now use the same code and produce the same results.

Nevertheless, results generated by *java 21* on Apple Silicon and Intel processors show small differences in results. The origin lies in *java* intrinsics that give implementations a little bit of freedom by requesting that the result must lie within `0.5 ulp` of the closest floating point representation. In sensitive calculations these minute differences can get amplified and possibly become substantial.

As a specific example, consider `x=-0x1.4000000000002p1`, which is approximately `-2.5` (more precisely `-2.500000000000001`, or `-4610560118520545278` with `Double.doubleToLongBits(x)`) encoded as a hex string using `Double.toHexString(x)`. The results for `Math.exp(x)` and `StrictMath.exp(x)` may differ for different architectures. The following table shows results for *java 21* on an Intel processor (MacBook Pro, 13" 2019, Four Thunderbolt 3 port with 2.8GHz Quad Core i7) and an Apple Silicon processor (Mac Studio 2023, Apple M2 Max):

| Architecture | `Math.exp(x)` | `StrictMath.exp(x)` |
| --- | --- | --- |
| Intel (long) | **`4590579268170609695`** | `4590579268170609696` |
| Intel (hex) | **`0x1.50385c094f41fp`** | `0x1.50385c094f42p` |
| Intel (dec) | **`0.08208499862389872`** | `0.08208499862389873` |
| Apple (long) | `4590579268170609696` | `4590579268170609696` |
| Apple (hex)| `0x1.50385c094f42p` | `0x1.50385c094f42p` |
| Apple (dec) | `0.08208499862389873` | `0.08208499862389873` |

At least in this example Apple Silicon returns the same result regardless of using `Math` or `StrictMath`, while the Intel results differ by one `ulp`.

Whether and how to address this issue remains open at this point. Ideally, all tests should be run with `StrictMath`, while regular simulations may not warrant the resulting computational overhead. For further information the question ['Is there still a difference between Math and StrictMath after Java 17 and JEP 306?'](https://stackoverflow.com/questions/76674101/is-there-still-a-difference-between-math-and-strictmath-after-java-17-and-jep-30) on stackoverflow may be helpful.

Fortunately, in practice, these differences are easily dealt with and only means that no unique set of tests can be generated that is valid on any platform. In case some *EvoLudo* tests happen to fail on your platform, you simply need to generate a new set of reference tests by running the script `./scripts/generatetests.sh` in the *EvoLudo* root direcrory. This generates a set of reference files in `EvoLudoTest/test/references` in a new directory with the name of the current git version. If all tests are successfully generated the symbolic link `current` is adjusted to point to the new set. Now all test can be run with the script `./scripts/runtests.sh` and pass (until an issue is introduced).

In general, all tests should always pass on the `master` branch but is not guaranteed. However, at least starting with `v1.3.1` tests are updated (if necessary) in the subsequent commit whenever a tag is assigned. This ensures that the tests have the version of the tag.
