# [*EvoLudo*](https://www.evoludo.org) Tests
***Testing consistency of the Evolutionary Dynamics Simulation Toolkit***

Historically, for reasons of efficiency *java* provided minimal freedom in the actual implementations of mathematical functions on different architectures. Primarily this relates to the numerical accuracy in intermediate results. For example, using an extended range for exponents for intermediate calculations could prevent numerical overflows or underflows in the final result. In contrast, sticking to *java*'s `double` precision throughout the calculations could potentially yield slightly different results.

The `java` keyword `strictfp` ensures that all intermediate results are consistently using `double` precision. However, implementations of `java.lang.Math` may resort to native numerical libraries where the format of intermediate results is beyond the control of `java`. For this reason `java.lang.Math` is accompanied by `java.lang.StrictMath`, which ensures that all intermediate results are also restricted to `double` precision. Using `java.lang.StrictMath` guarantees that all numerical computations yield identical results regardless of the architecture but may come with a computational penalty because platform dependent optimizations may not be available.

Since *java 17* the keyword `strictfp` is deprecated and all floating-point expressions are evaluated strictly such that `strictfp` is no longer needed. However, this does not imply that `java.lang.Math` and `java.lang.StrictMath` yield the same results!

For example, results generated by *java 21* on Apple Silicon and Intel processors show small differences in the least significant bits. The origin lies in the *java* specifications that cuts implementations a little slack by requesting that the result must lie within `0.5 ulp` of the closest floating point representation. In sensitive calculations these minute differences can get amplified and possibly become substantial.

As a specific example, consider `x=-0x1.4000000000002p1`, which is approximately `-2.5` encoded as a hex string using `Double.toHexString(x)` (more precisely `-2.500000000000001`, or `-4610560118520545278` with `Double.doubleToLongBits(x)`). The results for `Math.exp(x)` and `StrictMath.exp(x)` may differ for different architectures. The following table shows results for *java 21* on an Intel processor (MacBook Pro, 13" 2019, Four Thunderbolt 3 port with 2.8GHz Quad Core i7) and an Apple Silicon processor (Mac Studio 2023, Apple M2 Max):

| Architecture | `Math.exp(x)` | `StrictMath.exp(x)` |
| --- | --- | --- |
| Intel (dec) | **`0.08208499862389872`** | `0.08208499862389873` |
| Intel (long) | **`4590579268170609695`** | `4590579268170609696` |
| Intel (hex) | **`0x1.50385c094f41fp`** | `0x1.50385c094f42p` |
| Apple (dec) | `0.08208499862389873` | `0.08208499862389873` |
| Apple (long) | `4590579268170609696` | `4590579268170609696` |
| Apple (hex) | `0x1.50385c094f42p` | `0x1.50385c094f42p` |

At least in this example Apple Silicon returns the same result regardless of using `Math` or `StrictMath`, while the Intel results differ by one `ulp`.

Whether and how to address this issue remains open at this point. Ideally, all tests should be run with `StrictMath`, while regular simulations may not warrant the resulting computational overhead. For further information the questions ['Is there still a difference between Math and StrictMath after Java 17 and JEP 306?'](https://stackoverflow.com/questions/76674101/is-there-still-a-difference-between-math-and-strictmath-after-java-17-and-jep-30) and ['What's the difference between java.lang.Math and java.lang.StrictMath?'](https://stackoverflow.com/questions/4232231/whats-the-difference-between-java-lang-math-and-java-lang-strictmath) on stackoverflow may be helpful. In particular, note the link to ['software implementations'](https://en.wikipedia.org/wiki/Sine_and_cosine#Software_implementations) on the Wikipedia page on *Sine and Cosine*, which states the surprising fact that no standard exists for numerically implementing even such common functions as `sin(x)` and `cos(x)`.

Fortunately, in practice, these differences are easily dealt with, and they only mean that no unique set of tests can be generated that is valid on any architecture. In case some *EvoLudo* tests happen to fail on your platform, you simply need to generate a new set of reference tests. 

> [!IMPORTANT]
> The new set of reference tests *must* be generated *before* making any changes to the source code! 

A new set of reference tests is generated by running the script `./scripts/generatetests.sh` in the *EvoLudo* root directory. The reference files are stored in a new directory with the name of the current git version in `EvoLudoTest/test/references`. For all tests that pass a symbolic link is generated pointing to the existing test file to conserve resources. If all tests are successfully generated, the symbolic link `current` is adjusted to point to the new set. Now all tests can be run with the script `./scripts/runtests.sh` and pass (until an issue is introduced).

In general, all tests should always pass on the `master` branch, but this is not guaranteed. However, at least starting with `v1.3.1` tests are updated (if necessary) in the subsequent commit whenever a tag is assigned. This ensures that the tests have the version of the tag.
